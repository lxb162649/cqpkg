diff -Nuar cqpkg_manager-0.0.1/clone cqpkg_manager-0.0.1-diff/clone
--- cqpkg_manager-0.0.1/clone	2025-06-17 10:32:23.251448625 +0800
+++ cqpkg_manager-0.0.1-diff/clone	2025-06-17 12:25:26.513088120 +0800
@@ -1,87 +1,167 @@
 #!/bin/bash
 
+# 颜色定义
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[0;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+# 日志函数
+log_info() {
+    echo -e "${GREEN}[INFO]${NC} $1"
+}
+
+log_warn() {
+    echo -e "${YELLOW}[WARN]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1" >&2
+}
+
 # 帮助信息
 show_help() {
-    cat <<EOF
-功能说明：
-- 从指定仓库克隆软件包源码并配置RPM构建环境
-- 支持欧拉（OpenEuler）、龙蜥（Anolis OS）和CQ内部仓库
-- 自动生成SOURCEINFO.yaml元数据文件
-
-使用语法：
-clone <包名> [分支名]
-
-参数说明：
-  <包名>        必需，软件包名称（如：httpd）
-
-选项：
-  -h, --help    显示此帮助信息
-
-操作流程：
-1. 输入仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）
-2. 输入分支名（默认：master）
-3. 自动克隆代码
-4. 配置$HOME/rpmbuild目录结构(y/n)
-5. 生成包含开源协议、上游信息的SOURCEINFO.yaml(欧拉或龙蜥仓库)
-
-示例：
-1. 克隆httpd
-   clone httpd
-
-EOF
+    echo -e "${BLUE}功能说明：${NC}"
+    echo -e "  ${GREEN}•${NC} 从指定仓库克隆软件包源码并配置RPM构建环境"
+    echo -e "  ${GREEN}•${NC} 支持欧拉（OpenEuler）、龙蜥（Anolis OS）和CQ内部仓库"
+    echo -e "  ${GREEN}•${NC} 自动生成SOURCEINFO.yaml元数据文件"
+    echo
+    echo -e "${BLUE}使用语法：${NC}"
+    echo -e "  clone ${YELLOW}<包名>${NC} [分支名]"
+    echo
+    echo -e "${BLUE}参数说明：${NC}"
+    echo -e "  ${YELLOW}<包名>${NC}        必需，软件包名称（如：httpd）"
+    echo
+    echo -e "${BLUE}选项：${NC}"
+    echo -e "  ${YELLOW}-h, --help${NC}    显示此帮助信息"
+    echo
+    echo -e "${BLUE}操作流程：${NC}"
+    echo -e "  ${GREEN}1.${NC} 输入仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）"
+    echo -e "  ${GREEN}2.${NC} 输入分支名（默认：master）"
+    echo -e "  ${GREEN}3.${NC} 自动克隆代码"
+    echo -e "  ${GREEN}4.${NC} 配置$HOME/rpmbuild目录结构(y/n)"
+    echo -e "  ${GREEN}5.${NC} 生成包含开源协议、上游信息的SOURCEINFO.yaml(欧拉或龙蜥仓库)"
+    echo
+    echo -e "${BLUE}示例：${NC}"
+    echo -e "  ${GREEN}1.${NC} 克隆httpd"
+    echo -e "     clone httpd"
+    echo
 }
 
 # 清理旧目录
 clean_env() {
-    echo "正在清理旧环境..."
-    rm -rf "$PKG_PATH"
-    if [[ $dir == "y" ]]; then
-        rm -rf $HOME/rpmbuild
-    fi 
+    log_info "正在清理旧环境..."
+    if [[ -d "$PKG_PATH" ]]; then
+        rm -rf "$PKG_PATH" || { log_error "清理目录 $PKG_PATH 失败"; return 1; }
+    fi
+    
+    if [[ "$CREATE_RPMBUILD_DIR" == "y" && -d "$HOME/rpmbuild" ]]; then
+        rm -rf "$HOME/rpmbuild" || { log_error "清理目录 $HOME/rpmbuild 失败"; return 1; }
+    fi
+    
+    return 0
 }
 
 # 克隆仓库函数
 clone_repo() {
     local upstream_url=$1
-    git clone -b "$branch" "$upstream_url" && return 0
-    rm -rf "$PKG_PATH"  # 克隆失败清理残留
-    return 1
+    log_info "正在克隆仓库: $upstream_url (分支: $CLONE_BRANCH)"
+    
+    if ! git clone -b "$CLONE_BRANCH" "$upstream_url" "$PKG_PATH"; then
+        log_error "克隆失败，清理残留文件..."
+        if [[ -d "$PKG_PATH" ]]; then
+            rm -rf "$PKG_PATH"
+        fi
+        return 1
+    fi
+    
+    log_info "克隆成功"
+    return 0
 }
 
 # 移动文件到rpmbuild目录
 mv_files() {
-    echo "正在创建工作路径目录结构 $WORK_PATH ..."
-    mkdir -p $WORK_PATH/{SPECS,SOURCES} && echo "创建工作路径目录结构成功" || { echo "创建工作路径目录结构失败"; exit 1; }
-    echo "--------------------"
-    echo "正在整理文件到 $WORK_PATH ..."
-    mv $PKG_PATH/*.spec $WORK_PATH/SPECS/ && echo "移动SPEC文件成功" || { echo "移动SPEC文件失败"; exit 1; }
-    find $PKG_PATH -maxdepth 1 -type f ! -name ".*" -exec mv {} $WORK_PATH/SOURCES/ \; && echo "移动资源文件成功"|| { echo "移动资源文件失败"; exit 1; }
-    if [[ $dir == "y" ]]; then
-        mv $PKG_PATH/.gitignore $WORK_PATH && echo "移动.gitignore文件成功" || { echo "移动.gitignore文件失败"; exit 1; }
+    log_info "正在创建工作路径目录结构 $WORK_PATH ..."
+    
+    mkdir -p "$WORK_PATH"/{SPECS,SOURCES} || { log_error "创建工作路径目录结构失败"; return 1; }
+
+    log_info "正在整理文件到 $WORK_PATH ..."
+    
+    # 移动SPEC文件
+    if [[ -n $(find "$PKG_PATH" -maxdepth 1 -name "*.spec" -print -quit) ]]; then
+        mv "$PKG_PATH"/*.spec "$WORK_PATH/SPECS/" || { log_error "移动SPEC文件失败"; return 1; }
+        log_info "移动SPEC文件成功"
+    else
+        log_warn "未找到SPEC文件"
+    fi
+    
+    # 移动资源文件
+    if [[ -n $(find "$PKG_PATH" -maxdepth 1 -type f ! -name ".*" -print -quit) ]]; then
+        find "$PKG_PATH" -maxdepth 1 -type f ! -name ".*" -exec mv {} "$WORK_PATH/SOURCES/" \; || { log_error "移动资源文件失败"; return 1; }
+        log_info "移动资源文件成功"
+    else
+        log_warn "未找到可移动的资源文件"
+    fi
+    
+    # 处理.gitignore
+    if [[ "$CREATE_RPMBUILD_DIR" == "y" ]]; then
+        if [[ -f "$PKG_PATH/.gitignore" ]]; then
+            mv "$PKG_PATH/.gitignore" "$WORK_PATH" || { log_error "移动.gitignore文件失败"; return 1; }
+            log_info "移动.gitignore文件成功"
+        fi
         rm -rf "$PKG_PATH"
+        log_info "删除原克隆目录"
     else
-        rm -rf "$WORK_PATH/.git"
+        if [[ -d "$WORK_PATH/.git" ]]; then
+            rm -rf "$WORK_PATH/.git"
+            log_info "删除.git目录"
+        fi
+    fi
+    
+    log_info "整理文件完成"
+    return 0
+}
+
+# 创建.gitignore文件
+create_gitignore() {
+    log_info "正在创建.gitignore文件..."
+    
+    cat > "$PKG_PATH/.gitignore" << EOF
+#rpm
+RPMS
+SRPMS
+BUILDROOT
+#vscode
+.vscode 
+EOF
+    
+    if [[ $? -eq 0 ]]; then
+        log_info ".gitignore文件创建成功"
+        return 0
+    else
+        log_error ".gitignore文件创建失败"
+        return 1
     fi
-    echo "整理文件完成"
-    echo "--------------------"
 }
 
 # 生成元数据文件
 generate_metadata() {
-    cd "$WORK_PATH" || return 1
+    cd "$WORK_PATH" || { log_error "无法进入目录 $WORK_PATH"; return 1; }
     
     local spec_file=$(ls SPECS/*.spec 2>/dev/null)
     
-    if [ -z "$spec_file" ]; then
-        echo "错误：未找到SPEC文件" >&2
-        exit 1
+    if [[ -z "$spec_file" ]]; then
+        log_error "未找到SPEC文件"
+        return 1
     fi
     
     local url=$(awk '/^(URL|Url):/ {print $2}' "$spec_file")
     local license=$(grep -oP 'License:\s*\K.*' "$spec_file" | tr '\n' ' ')
+    
     # 确定上游仓库URL
     local upstream_url
-    if [ "$repo" = "a" ]; then
+    if [[ "$REPO_TYPE" == "a" ]]; then
         upstream_url="https://gitee.com/src-openeuler/${PKG_NAME}.git"
     else
         upstream_url="https://gitee.com/src-anolis-os/${PKG_NAME}.git"
@@ -93,16 +173,82 @@
   - ${license}
 upstream:
   src: ${upstream_url}
-  branch: ${branch}
+  branch: ${CLONE_BRANCH}
 origin:
   src: ${url:-"未指定上游地址"}
 EOF
 
-    echo "元数据文件生成完成 $(pwd)/SOURCEINFO.yaml"
-    echo "--------------------"
+    log_info "元数据文件生成完成 $(pwd)/SOURCEINFO.yaml"
+    return 0
+}
+
+# 验证输入
+validate_input() {
+    if [[ -z "$PKG_NAME" ]]; then
+        log_error "缺少包名参数"
+        show_help
+        return 1
+    fi
+    
+    # 验证包名是否符合命名规范（简化版）
+    if [[ ! "$PKG_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
+        log_error "包名包含非法字符，只能使用字母、数字、连字符和下划线"
+        return 1
+    fi
+    
+    return 0
+}
+
+# 克隆CQ内部仓库
+clone_cq_repo() {
+    # CQ内部仓库列表（按优先级排序）
+    local cq_upstream_urls=(
+        "http://192.168.10.152/cyos-security/public/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/protected/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/private/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/trash/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/iso/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/toolkits/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/transition/python3.11/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/transition/deb_to_rpm/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/transition/xfce/$PKG_NAME.git"
+        "http://192.168.10.152/cyos-security/transition/$PKG_NAME.git"
+        "http://192.168.10.152/lixuebing/$PKG_NAME.git"
+    )
+    
+    log_info "尝试从CQ内部仓库克隆..."
+    
+    local cloned=false
+    for upstream_url in "${cq_upstream_urls[@]}"; do
+        log_info "检查仓库: $upstream_url"
+        if git ls-remote "$upstream_url" &>/dev/null; then
+            log_info "找到仓库，开始克隆..."
+            if clone_repo "$upstream_url"; then
+                cloned=true
+                break
+            fi
+        fi
+    done
+    
+    if [[ "$cloned" == false ]]; then
+        log_error "未在任何CQ内部仓库中找到 $PKG_NAME"
+        return 1
+    fi
+    
+    return 0
 }
 
 main() {
+    # 初始化变量
+    PKG_NAME=""
+    DEFAULT_BRANCH="master"
+    CLONE_BRANCH="$DEFAULT_BRANCH"
+    REPO_TYPE=""
+    CREATE_RPMBUILD_DIR=""
+    PKG_PATH=""
+    WORK_PATH=""
+    
     # 解析命令行参数（支持选项在任意位置）
     while [[ $# -gt 0 ]]; do
         case "$1" in
@@ -115,98 +261,93 @@
                 if [[ -z "$PKG_NAME" ]]; then
                     PKG_NAME=$1
                 else
-                    echo "错误: 重复的路径参数 '$1'" >&2
-                    show_help
-                    exit 1
+                    # 如果已经有PKG_NAME，则认为是分支名
+                    CLONE_BRANCH=$1
                 fi
                 ;;
         esac
         shift
     done
-
-    # 检查包名
-    if [ -z "$PKG_NAME" ]; then
-        echo "错误：缺少包名参数" >&2
+    
+    # 验证输入
+    if ! validate_input; then
         exit 1
     fi
-
-    repo=$(read -p "请选择仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）: " && echo "$REPLY")
-
-    branch=$(read -p "请输入克隆分支（默认master）: " && [[ -n "$REPLY" ]] && echo "$REPLY" || echo "master")
-
+    
+    # 获取仓库类型
+    read -p "请选择仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）: " REPO_TYPE
+    
+    # 获取分支名
+    read -p "请输入克隆分支（默认 $DEFAULT_BRANCH）: " input_branch
+    if [[ -n "$input_branch" ]]; then
+        CLONE_BRANCH="$input_branch"
+    fi
+    
     PKG_PATH="$(pwd)/$PKG_NAME"
-
-    dir=$(read -p "是否将代码放入$HOME/rpmbuild目录（输入y放入此目录，默认放到 $PKG_PATH 目录）: " && echo "$REPLY")
-    case "$repo" in
+    
+    # 是否创建rpmbuild目录
+    read -p "是否将代码放入$HOME/rpmbuild目录（输入y放入此目录，默认放到 $PKG_PATH 目录）: " CREATE_RPMBUILD_DIR
+    
+    # 清理环境
+    if ! clean_env; then
+        exit 1
+    fi
+    
+    # 根据仓库类型克隆
+    case "$REPO_TYPE" in
         a)
-            clean_env  # 初始化环境
             local upstream_url="https://gitee.com/src-openeuler/${PKG_NAME}.git"
-            clone_repo "$upstream_url" || { echo "龙蜥仓库克隆失败"; exit 1; }
-            echo "欧拉仓库克隆成功"
-            echo "--------------------"
+            if ! clone_repo "$upstream_url"; then
+                log_error "欧拉仓库克隆失败"
+                exit 1
+            fi
+            log_info "欧拉仓库克隆成功"
             ;;
         b)
-            clean_env  # 初始化环境
             local upstream_url="https://gitee.com/src-anolis-os/${PKG_NAME}.git"
-            clone_repo "$upstream_url" || { echo "龙蜥仓库克隆失败"; exit 1; }
-            echo "龙蜥仓库克隆成功"
-            echo "--------------------"
+            if ! clone_repo "$upstream_url"; then
+                log_error "龙蜥仓库克隆失败"
+                exit 1
+            fi
+            log_info "龙蜥仓库克隆成功"
             ;;
         *)
-            clean_env  # 初始化环境
-            # CQ内部仓库列表（按优先级排序）
-            local cq_upstream_urls=(
-                "http://192.168.10.152/cyos-security/public/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/protected/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/private/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/trash/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/iso/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/toolkits/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/transition/python3.11/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/transition/deb_to_rpm/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/transition/xfce/$PKG_NAME.git"
-                "http://192.168.10.152/cyos-security/transition/$PKG_NAME.git"
-                "http://192.168.10.152/lixuebing/$PKG_NAME.git"
-            )
-            local upstream_url=""
-            for upstream_url in "${cq_upstream_urls[@]}"; do
-                git ls-remote $upstream_url &>/dev/null && clone_repo "$upstream_url" && break
-            done
+            if ! clone_cq_repo; then
+                exit 1
+            fi
+            log_info "CQ内部仓库克隆成功!"
+            
+            # CQ仓库不需要生成元数据，直接退出
+            exit 0
             ;;
     esac
-    if [ ! -f "$PKG_PATH/.gitignore" ] && $(find $PKG_PATH -name '*.spec' &>/dev/null && echo "true"); then
-        echo "正在创建.gitignore文件..."
-        cat > $PKG_PATH/.gitignore << EOF
-#rpm
-RPMS
-SRPMS
-BUILDROOT
-#vscode
-.vscode 
-EOF
-        if [ $? -eq 0 ]; then
-            echo ".gitignore文件创建成功" 
-            echo "--------------------"  
-        else
-            echo ".gitignore文件创建失败"
-            exit 1      
+    
+    # 检查是否需要创建.gitignore
+    if [[ ! -f "$PKG_PATH/.gitignore" ]] && [[ -n $(find "$PKG_PATH" -name '*.spec' &>/dev/null) ]]; then
+        if ! create_gitignore; then
+            exit 1
         fi
     fi
-
-    if [[ $repo != "a" && $repo != "b" ]]; then
-        echo "CQ内部仓库克隆成功!"
-        exit 0
-    fi
-
-    if [[ $dir == "y" ]]; then
+    
+    # 设置工作路径
+    if [[ "$CREATE_RPMBUILD_DIR" == "y" ]]; then
         WORK_PATH="$HOME/rpmbuild"  # 放入$HOME/rpmbuild目录
     else
         WORK_PATH="$PKG_PATH"  # 保持原目录结构
     fi
-    mv_files
-
-    generate_metadata && echo "操作完成！RPM构建环境已配置到 $PKG_PATH" || { echo "元数据生成失败"; exit 1; }
+    
+    # 移动文件
+    if ! mv_files; then
+        exit 1
+    fi
+    
+    # 生成元数据
+    if ! generate_metadata; then
+        log_error "元数据生成失败"
+        exit 1
+    fi
+    
+    log_info "操作完成！RPM构建环境已配置到 $WORK_PATH"
 }
 
-main "$@"
+main "$@"    
diff -Nuar cqpkg_manager-0.0.1/compile cqpkg_manager-0.0.1-diff/compile
--- cqpkg_manager-0.0.1/compile	2025-06-17 10:32:23.252448632 +0800
+++ cqpkg_manager-0.0.1-diff/compile	2025-06-17 11:41:21.876101380 +0800
@@ -13,116 +13,129 @@
 RED='\033[0;31m'
 GREEN='\033[0;32m'
 YELLOW='\033[0;33m'
+BLUE='\033[0;34m'
 NC='\033[0m' # 恢复默认颜色
 
+#------------------------------ 日志函数 ------------------------------#
+log_info() {
+    echo -e "${GREEN}[INFO]${NC} $1"
+}
+
+log_warn() {
+    echo -e "${YELLOW}[WARN]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1" >&2
+    exit 1
+}
+
 #------------------------------ 帮助信息 ------------------------------#
 show_help() {
-    echo -e "${GREEN}RPM包编译工具${NC}"
+    echo -e "${BLUE}RPM包编译工具${NC}"
     echo
     echo -e "${YELLOW}功能说明：${NC}"
-    echo "自动安装编译依赖、构建RPM包并展示结果"
-    echo "支持两种模式："
-    echo "  1. 全局模式：基于默认的 $HOME/rpmbuild 目录"
-    echo "  2. 本地模式：基于指定的源码包目录"
+    echo -e "  ${GREEN}•${NC} 自动安装编译依赖、构建RPM包并展示结果"
+    echo -e "  ${GREEN}•${NC} 支持两种模式："
+    echo "    1. 全局模式：基于默认的 $HOME/rpmbuild 目录"
+    echo "    2. 本地模式：基于指定的源码包目录"
     echo
     echo -e "${YELLOW}使用语法：${NC}"
-    echo "$(basename "$0") [选项] [路径名]"
+    echo "  $(basename "$0") [选项] [路径名]"
     echo
     echo -e "${YELLOW}选项：${NC}"
-    echo "  -ba          构建二进制和源码RPM包"
-    echo "  -bp          只执行到编译前阶段"
-    echo "  -bs          只构建源码RPM包"
-    echo "  -h, --help   显示此帮助信息"
+    echo -e "  ${GREEN}-ba${NC}        构建二进制和源码RPM包"
+    echo -e "  ${GREEN}-bp${NC}        只执行到编译前阶段"
+    echo -e "  ${GREEN}-bs${NC}        只构建源码RPM包"
+    echo -e "  ${GREEN}-h, --help${NC}   显示此帮助信息"
     echo
     echo -e "${YELLOW}参数：${NC}"
     echo "  [路径名]     可选，源码包目录名 (默认使用 $HOME/rpmbuild)"
     echo
-    echo -e "${YELLOW}示例(默认参数为 -ba -bp)：${NC}"
-    echo "1. 全局模式 (编译 $HOME/rpmbuild 中的SPEC文件)："
-    echo "   $(basename "$0")"
-    echo
-    echo "2. 本地模式 (编译指定目录中的包)："
-    echo "   $(basename "$0") felix-scr"
-    echo
-    echo "3. 只构建源码RPM包："
-    echo "   $(basename "$0") -bs /path/to/package"
-    echo
-    echo "4. 同时执行多种构建类型："
-    echo "   $(basename "$0") -ba -bs /path/to/package"
-
-}
-
-#------------------------------ 工具函数 ------------------------------#
-# 功能：显示错误信息并退出
-error_exit() {
-    echo -e "${RED}错误:${NC} $1" >&2
-    exit 1
+    echo -e "${YELLOW}示例(默认参数为 -ba -bp):${NC}"
+    echo "  1. 全局模式 (编译 $HOME/rpmbuild 中的SPEC文件):"
+    echo "     $(basename "$0")"
+    echo
+    echo "  2. 本地模式 (编译指定目录中的包):"
+    echo "     $(basename "$0") felix-scr"
+    echo
+    echo "  3. 只构建源码RPM包:"
+    echo "     $(basename "$0") -bs /path/to/package"
+    echo
+    echo "  4. 同时执行多种构建类型:"
+    echo "     $(basename "$0") -ba -bs /path/to/package"
+    exit 0
 }
 
 #------------------------------ 核心功能 ------------------------------#
 # 安装编译依赖
-install_deps() {
-    echo "正在安装编译依赖..."
-    if ! yum builddep -y "$SPEC_FILE" &>/dev/null; then
-        error_exit "安装依赖失败，请检查SPEC文件和网络连接"
+install_dependencies() {
+    log_info "正在安装编译依赖..."
+    
+    if ! yum builddep -y "$SPEC_FILE" &> /dev/null; then
+        log_error "安装依赖失败，请检查SPEC文件和网络连接"
     fi
-    echo -e "${GREEN}依赖安装完成${NC}"
+    log_info "依赖安装完成"
 }
 
 # 构建RPM包
-build_rpm() {
+build_rpm_package() {
     local build_type=$1
     local build_args=()
     
     # 设置自定义TOPDIR (如果不是全局模式)
     if [[ "$PKG_PATH" != "$HOME/rpmbuild" ]]; then
         build_args+=(-D "_topdir $PKG_PATH")
+        log_info "使用自定义TOPDIR: $PKG_PATH"
     fi
     
-    echo -e "\n${YELLOW}开始构建RPM包 (类型: $build_type)${NC}"
-    echo "SPEC文件: ${SPEC_FILE}"
+    log_info "开始构建RPM包 (类型: $build_type)"
+    log_info "SPEC文件: $(basename "$SPEC_FILE")"
     
     case "$build_type" in
         "ba")
+            log_info "构建二进制和源码RPM包..."
             rpmbuild -ba "${build_args[@]}" "$SPEC_FILE"
             ;;
         "bp")
+            log_info "执行到编译前阶段..."
             rpmbuild -bp "${build_args[@]}" "$SPEC_FILE"
             ;;
         "bs")
+            log_info "构建源码RPM包..."
             rpmbuild -bs "${build_args[@]}" "$SPEC_FILE"
             ;;
         *)
-            error_exit "未知的构建类型: $build_type"
+            log_error "未知的构建类型: $build_type"
             ;;
     esac
     
-    echo -e "${GREEN}构建完成 (类型: $build_type)${NC}"
+    log_info "构建完成 (类型: $build_type)"
 }
 
 # 展示构建结果
-show_results() {
+show_build_results() {
     local rpms_dir="${PKG_PATH}/RPMS"
     local srpms_dir="${PKG_PATH}/SRPMS"
     
-    echo -e "\n${YELLOW}构建结果:${NC}"
+    log_info "构建结果:"
     
     # 检查RPM目录
     if [[ ! -d "$rpms_dir" ]]; then
-        echo -e "${RED}警告: 未生成RPM文件目录${NC}"
+        log_warn "未生成RPM文件目录"
         return 1
     fi
     
     # 显示各架构的RPM包
     for arch in noarch x86_64; do
         local arch_dir="$rpms_dir/$arch"
-        echo -e "${GREEN}== $arch ==${NC}"
+        echo -e "${BLUE}== $arch ==${NC}"
         
         if [[ -d "$arch_dir" && "$(ls -A "$arch_dir" 2>/dev/null)" ]]; then
             local count=$(ls -1 "$arch_dir" | wc -l)
             echo -e "找到 ${YELLOW}$count${NC} 个RPM包:"
             ls -1 "$arch_dir" | while read -r file; do
-                echo "  - $file"
+                echo "$arch_dir/$file"
             done
         else
             echo "  无"
@@ -131,121 +144,118 @@
     done
     
     # 显示源码RPM包
-    echo -e "${GREEN}== 源码包 ==${NC}"
+    echo -e "${BLUE}== 源码包 ==${NC}"
     if [[ -d "$srpms_dir" && "$(ls -A "$srpms_dir" 2>/dev/null)" ]]; then
         local count=$(ls -1 "$srpms_dir" | wc -l)
         echo -e "找到 ${YELLOW}$count${NC} 个源码RPM包:"
         ls -1 "$srpms_dir" | while read -r file; do
-            echo "  - $file"
+            echo "$srpms_dir/$file"
         done
     else
         echo "  无"
     fi
+
+    return 0
 }
 
 #------------------------------ 主函数 ------------------------------#
 main() {
     # 初始化变量
-    local -a BUILD_TYPES=("ba" "bp")   # 存储要执行的构建类型
-    local PKG_NAME=""
+    local -a BUILD_TYPES=("ba" "bp")  # 默认构建类型
     local PKG_PATH=""
-    flag=0
+    local SPEC_FILE=""
+    
     # 解析命令行参数
     while [[ $# -gt 0 ]]; do
         case "$1" in
             -h|--help)
                 show_help
-                exit 0
                 ;;
             -ba|-bp|-bs)
-                # 移除默认构建类型
-                if [[ flag -eq "0" ]]; then
-                    flag=1
+                # 移除默认构建类型并添加新类型
+                if [[ ${#BUILD_TYPES[@]} -eq 2 ]]; then
                     BUILD_TYPES=()
-                    echo "移除默认构建类型"
+                    log_info "移除默认构建类型，使用自定义类型"
                 fi    
-                # 添加新的构建类型
                 local build_type="${1#-}"  # 移除前缀'-'
                 BUILD_TYPES+=("$build_type")
                 ;;
             *)
-                # 如果参数不是选项，则认为是PKG_NAME
-                if [[ -z "$PKG_NAME" ]]; then
-                    PKG_NAME=$1
+                # 设置工作目录
+                if [[ -z "$PKG_PATH" ]]; then
+                    if ! PKG_PATH="$(realpath -e "$1" 2>/dev/null)"; then
+                        log_error "错误：请提供有效的路径参数" >&2
+                    fi
                 else
-                    error_exit "重复的路径参数 '$1'"
+                    log_error "重复的路径参数 '$1'"
                 fi
                 ;;
         esac
         shift
     done
-
+    
     # 去重构建类型
-    local -a UNIQUE_BUILD_TYPES=()
+    local -a UNIQUE_TYPES=()
     for type in "${BUILD_TYPES[@]}"; do
-        if [[ ! " ${UNIQUE_BUILD_TYPES[*]} " =~ " ${type} " ]]; then
-            UNIQUE_BUILD_TYPES+=("$type")
+        if [[ ! " ${UNIQUE_TYPES[*]} " =~ " ${type} " ]]; then
+            UNIQUE_TYPES+=("$type")
+        fi
+    done
+    BUILD_TYPES=("${UNIQUE_TYPES[@]}")
+    
+    # 验证构建类型
+    for type in "${BUILD_TYPES[@]}"; do
+        if [[ ! "$type" =~ ^(ba|bp|bs)$ ]]; then
+            log_error "不支持的构建类型: $type"
         fi
     done
-    BUILD_TYPES=("${UNIQUE_BUILD_TYPES[@]}")
     
     # 确定工作目录
-    if [[ -z "$PKG_NAME" ]]; then
+    if [[ -z "$PKG_PATH" ]]; then
         PKG_PATH="$HOME/rpmbuild"
-        echo -e "${YELLOW}使用全局模式:${NC} $PKG_PATH"
+        log_info "使用全局模式: $PKG_PATH"
     else
-        PKG=$(basename "$PKG_NAME")
-        if ! echo "$PKG_NAME" | grep -q "/"; then
-            PKG_PATH="$(pwd)/$PKG"
-        else
-            PKG_PATH="$PKG_NAME"
-        fi
-        echo -e "${YELLOW}使用本地模式:${NC} $PKG_PATH"
-    fi
-    
-    # 检查目录是否存在
-    if [[ ! -d "$PKG_PATH" ]]; then
-        error_exit "目录不存在: $PKG_PATH"
+        log_info "使用本地模式: $PKG_PATH"
     fi
     
     # 查找SPEC文件
     local spec_files=("$PKG_PATH/SPECS"/*.spec)
     if [[ ${#spec_files[@]} -eq 0 ]]; then
-        error_exit "未找到SPEC文件: $PKG_PATH/SPECS/*.spec"
+        log_error "未找到SPEC文件: $PKG_PATH/SPECS/*.spec"
     elif [[ ${#spec_files[@]} -gt 1 ]]; then
-        echo -e "${YELLOW}警告: 找到多个SPEC文件，使用第一个:${NC}"
+        log_warn "找到多个SPEC文件，使用第一个:"
         for file in "${spec_files[@]}"; do
             echo "  - $(basename "$file")"
         done
     fi
     
     SPEC_FILE="${spec_files[0]}"
-    echo -e "${YELLOW}使用SPEC文件:${NC} $(basename "$SPEC_FILE")"
+    log_info "使用SPEC文件: $(basename "$SPEC_FILE")"
     
     # 切换到工作目录
-    cd "$PKG_PATH" || error_exit "无法切换到目录: $PKG_PATH"
+    cd "$PKG_PATH" || log_error "无法切换到目录: $PKG_PATH"
     
     # 安装依赖（只需要安装一次）
-    install_deps
+    install_dependencies
     
     # 执行所有构建类型
-    echo -e "\n${YELLOW}将要执行的构建类型:${NC} ${BUILD_TYPES[*]}"
+    log_info "将要执行的构建类型: ${BUILD_TYPES[*]}"
     
     for build_type in "${BUILD_TYPES[@]}"; do
-        build_rpm "$build_type"
+        build_rpm_package "$build_type"
     done
     
     # 显示结果 (仅对包含"ba"的构建)
     if [[ " ${BUILD_TYPES[*]} " =~ " ba " ]]; then
-        show_results
+        show_build_results
     else
-        echo -e "\n${YELLOW}注意: 未执行 '-ba' 构建，因此不显示结果${NC}"
+        log_info "注意: 未执行 '-ba' 构建，因此不显示结果"
     fi
     
-    echo -e "\n${GREEN}所有操作已完成${NC}"
+    log_info "${GREEN}所有操作已完成${NC}"
 }
 
 # 执行主函数
 if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
     main "$@"
-fi
+fi
\ 文件尾没有换行符
diff -Nuar cqpkg_manager-0.0.1/upload cqpkg_manager-0.0.1-diff/upload
--- cqpkg_manager-0.0.1/upload	2025-05-30 14:11:16.000000000 +0800
+++ cqpkg_manager-0.0.1-diff/upload	2025-06-17 12:25:08.928968557 +0800
@@ -1,116 +1,196 @@
 #!/bin/bash
 
+# 颜色定义
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[0;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # 恢复默认颜色
+
+# 日志函数
+log_info() {
+    echo -e "${GREEN}[INFO]${NC} $1"
+}
+
+log_warn() {
+    echo -e "${YELLOW}[WARN]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1" >&2
+}
+
 # 帮助信息
-help_msg() {
-    cat <<EOF
-功能说明：
-将本地代码上传至GitLab仓库指定分支，并支持提交信息规范
-
-使用语法：
-upload <路径名> <分支名> "<提交信息>"
-
-参数说明：
-  <路径名>        必需，目标仓库名称（如：felix-scr）
-  <分支名>      必需，目标分支（如：dev/test）
-  <提交信息>    必需，遵循规范（如："修复(spec): 优化SPEC文件"）
-
-规范示例：
-- 文档更新："文档(README): 更新安装步骤"
-- SPEC修复："修复(spec): 移除无效宏定义"
-- 上游同步："更新(同步欧拉仓库): 同步版本2.12.1"
-- 上游同步："更新(同步龙蜥仓库): 同步版本2.12.1"
-- 架构适配："适配(x86_64): 修复编译警告"
-
-操作流程：
-1. 选择代码来源（~/rpmbuild 或当前目录）
-2. 自动清理/复制文件
-3. 提交到指定分支并创建备份
-
-示例：
-upload nginx main "更新(龙蜥): 同步2.18.0版本"
-EOF
-}
-
-# 参数校验
-if [[ $1 == "-h" || $1 == "--help" ]]; then
-    help_msg
-    exit 0
-fi
-
-package_path=$1
-branch=$2
-commit_msg=$3  # 更清晰的变量名
-# 检查必填参数
-if [ -z "$package_path" ] || [ -z "$branch" ] || [ -z "$commit_msg" ]; then
-    echo "错误：缺少必填参数（路径名、分支、提交信息）" >&2
-    help_msg
+show_help() {
+    echo -e "${BLUE}代码上传工具${NC}"
+    echo
+    echo -e "${YELLOW}功能说明：${NC}"
+    echo -e "  ${GREEN}•${NC} 将本地代码上传至GitLab仓库指定分支"
+    echo -e "  ${GREEN}•${NC} 支持提交信息规范和RPM包备份"
+    echo
+    echo -e "${YELLOW}使用语法：${NC}"
+    echo "  upload <路径名> <分支名> \"<提交信息>\""
+    echo
+    echo -e "${YELLOW}参数说明：${NC}"
+    echo -e "  ${GREEN}<路径名>${NC}      必需，目标仓库本地路径（如：~/projects/felix-scr）"
+    echo -e "  ${GREEN}<分支名>${NC}      必需，目标分支（如：dev/test 或 main）"
+    echo -e "  ${GREEN}<提交信息>${NC}    必需，遵循规范（如：\"修复(spec): 优化SPEC文件\"）"
+    echo
+    echo -e "${YELLOW}提交信息规范示例：${NC}"
+    echo -e "  ${GREEN}-${NC} 文档更新：\"文档(README): 更新安装步骤\""
+    echo -e "  ${GREEN}-${NC} SPEC修复：\"修复(spec): 移除无效宏定义\""
+    echo -e "  ${GREEN}-${NC} 上游同步：\"更新(同步欧拉仓库): 同步版本2.12.1\""
+    echo -e "  ${GREEN}-${NC} 上游同步：\"更新(同步龙蜥仓库): 同步版本2.12.1\""
+    echo -e "  ${GREEN}-${NC} 架构适配：\"适配(x86_64): 修复编译警告\""
+    echo
+    echo -e "${YELLOW}操作流程：${NC}"
+    echo -e "  ${GREEN}1.${NC} 选择代码来源（~/rpmbuild 或当前目录）"
+    echo -e "  ${GREEN}2.${NC} 自动清理/复制文件"
+    echo -e "  ${GREEN}3.${NC} 提交到指定分支并创建备份"
+    echo
+    echo -e "${YELLOW}示例：${NC}"
+    echo "  upload nginx main \"更新(龙蜥): 同步2.18.0版本\""
+}
+
+# 错误处理函数
+exit_with_error() {
+    log_error "$1"
     exit 1
-fi
+}
 
-# 交互式确认
-read -p "是否从 ~/rpmbuild 目录上传代码？(y/yes/其他跳过): " choice
-choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]')
+# 验证参数
+validate_arguments() {
+    if [[ $1 == "-h" || $1 == "--help" ]]; then
+        show_help
+        exit 0
+    fi
+    
+    if ! PKG_PATH="$(realpath -e "$1" 2>/dev/null)"; then
+        log_error "错误：请提供有效的路径参数" >&2
+    fi
+    BRANCH=$2
+    COMMIT_MSG=$3
+    
+    if [ -z "$PKG_PATH" ] || [ -z "$BRANCH" ] || [ -z "$COMMIT_MSG" ]; then
+        exit_with_error "缺少必填参数（路径名、分支、提交信息）"
+    fi
+    
+    log_info "参数验证通过"
+}
 
 # 代码复制逻辑
-if [[ "$choice" =~ ^(y|yes)$ ]]; then
-    echo "正在从 ~/rpmbuild 复制代码..."
-    # 清理旧文件（使用绝对路径避免误删）
-    rm -rf "$package_path/BUILD" "$package_path/SOURCES" "$package_path/SPECS" "$package_path/SOURCEINFO.yaml"
+copy_code_from_rpmbuild() {
+    log_info "正在从 ~/rpmbuild 复制代码..."
+    LOCAL_RPMBUILD="$HOME/rpmbuild"
+    
+    # 检查rpmbuild目录是否存在
+    if [ ! -d "$LOCAL_RPMBUILD" ]; then
+        exit_with_error "~/rpmbuild 目录不存在"
+    fi
+    
+    # 清理目标目录中的RPM相关文件（使用绝对路径避免误删）
+    rm -rf "$PKG_PATH/BUILD" "$PKG_PATH/SOURCES" "$PKG_PATH/SPECS" "$PKG_PATH/SOURCEINFO.yaml"
+    
     # 复制文件（保留目录结构）
-    cp -rf ~/rpmbuild/. "$package_path/" || {
-        echo "错误：复制文件失败" >&2
-        exit 1
-    }
-else
-    echo "使用当前目录代码：$package_path"
-fi
-
-# 进入仓库目录
-cd "$package_path" || {
-    echo "错误：目录不存在：$package_path" >&2
-    exit 1
+    if ! cp -rf "$LOCAL_RPMBUILD"/. "$PKG_PATH/"; then
+        exit_with_error "复制文件失败"
+    fi
+    
+    log_info "代码复制完成"
 }
 
-# 分支管理
-git branch -M "$branch"  # 强制切换/创建分支
-git checkout "$branch"    # 确保在目标分支
-
-# 提交代码
-git add -A
-git commit -m "$commit_msg" || {
-    echo "错误：提交失败，可能无变更" >&2
-    exit 1
+# 管理Git分支
+manage_git_branch() {
+    log_info "进入仓库目录: $PKG_PATH"
+    cd "$PKG_PATH" || exit_with_error "目录不存在: $PKG_PATH"
+    
+    log_info "切换到分支: $BRANCH"
+    git branch -M "$BRANCH"  # 强制切换/创建分支
+    git checkout "$BRANCH"    # 确保在目标分支
+    
+    log_info "分支管理完成"
 }
 
-# 推送至远程仓库
-echo "正在推送至 origin/$branch..."
-git push -uf origin "$branch" || {
-    echo "错误：推送失败，请检查网络和权限" >&2
-    exit 1
+# 提交并推送代码
+commit_and_push_code() {
+    log_info "准备提交代码..."
+    git add -A
+    
+    log_info "提交代码 with message: $COMMIT_MSG"
+    if ! git commit -m "$COMMIT_MSG"; then
+        log_warn "提交失败，可能没有代码变更"
+        exit 0  # 无变更时正常退出
+    fi
+    
+    log_info "正在推送至 origin/$BRANCH..."
+    if ! git push -uf origin "$BRANCH"; then
+        exit_with_error "代码推送失败，请检查网络和权限"
+    fi
+    
+    log_info "代码推送完成"
 }
 
 # 备份RPM包
-create_backup() {
+backup_rpm_packages() {
     local backup_dir="../success/RPMS"
-    mkdir -p $backup_dir/{noarch,x86_64}
+    log_info "准备备份RPM包到 $backup_dir"
+    
+    mkdir -p "$backup_dir"/{noarch,x86_64}
     
     # 备份noarch架构包
-    if ls -1 $package_path/RPMS/noarch/*.rpm &> /dev/null; then
-        cp -v $package_path/RPMS/noarch/*.rpm "$backup_dir/noarch/"
+    if ls -1 "$PKG_PATH/RPMS/noarch"/*.rpm &> /dev/null; then
+        log_info "备份noarch架构RPM包..."
+        cp -v "$PKG_PATH/RPMS/noarch"/*.rpm "$backup_dir/noarch/"
+    else
+        log_warn "未找到noarch架构RPM包"
     fi
     
     # 备份x86_64架构包
-    if ls -1 $package_path/RPMS/x86_64/*.rpm &> /dev/null; then
-        cp -v $package_path/RPMS/x86_64/*.rpm "$backup_dir/x86_64/"
+    if ls -1 "$PKG_PATH/RPMS/x86_64"/*.rpm &> /dev/null; then
+        log_info "备份x86_64架构RPM包..."
+        cp -v "$PKG_PATH/RPMS/x86_64"/*.rpm "$backup_dir/x86_64/"
+    else
+        log_warn "未找到x86_64架构RPM包"
     fi
+    
+    log_info "RPM包备份完成"
 }
 
-# 执行备份（仅当存在RPM文件时）
-if [ "$(ls -A RPMS 2>/dev/null)" ]; then
-    echo "创建备份到 ../success/RPMS"
-    create_backup
-else
-    echo "警告：未找到RPM文件，跳过备份"
-fi
+# 主函数
+main() {
+    # 1. 验证参数
+    validate_arguments "$@"
+    
+    log_info "开始执行代码上传流程"
+    
+    # 2. 交互式确认代码来源
+    read -p "是否从 ~/rpmbuild 目录上传代码？(y/yes/其他跳过): " choice
+    choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]')
+    
+    if [[ "$choice" =~ ^(y|yes)$ ]]; then
+        copy_code_from_rpmbuild
+    else
+        log_info "使用当前目录代码: $PKG_PATH"
+    fi
+    
+    # 3. 管理Git分支
+    manage_git_branch
+    
+    # 4. 提交并推送代码
+    commit_and_push_code
+    
+    # 5. 备份RPM包（仅当存在RPM文件时）
+    if [ "$(ls -A "$PKG_PATH/RPMS" 2>/dev/null)" ]; then
+        
+        log_info "开始备份RPM包"
+        backup_rpm_packages
+    else
+        log_warn "警告：未找到RPM文件，跳过备份"
+    fi
+    
+    log_info "${GREEN}所有操作已完成！${NC}"
+    log_info "代码已推送至 $BRANCH 分支"
+}
 
-echo "操作完成！代码已推送至 $branch 分支"
\ 文件尾没有换行符
+# 执行主函数
+main "$@"
