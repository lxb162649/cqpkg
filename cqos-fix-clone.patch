diff -Nuar cqpkg_manager-0.0.1/clone cqpkg_manager-0.0.1-diff/clone
--- cqpkg_manager-0.0.1/clone	2025-06-11 10:50:02.414108427 +0800
+++ cqpkg_manager-0.0.1-diff/clone	2025-06-11 13:54:51.935127733 +0800
@@ -1,14 +1,7 @@
 #!/bin/bash
 
-CHECK_RESULT() {
-    if [ $1 -ne 0 ]; then
-        echo "错误：$2" >&2
-        exit 1
-    fi
-}
-
 # 帮助信息
-help_msg() {
+show_help() {
     cat <<EOF
 功能说明：
 - 从指定仓库克隆软件包源码并配置RPM构建环境
@@ -20,143 +13,78 @@
 
 参数说明：
   <包名>        必需，软件包名称（如：httpd）
-  [分支名]      可选，默认master
 
 选项：
   -h, --help    显示此帮助信息
 
 操作流程：
 1. 输入仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）
-2. 自动克隆代码并配置~/rpmbuild目录结构
-3. 生成包含开源协议、上游信息的SOURCEINFO.yaml
+2. 输入分支名（默认：master）
+3. 自动克隆代码
+4. 配置$HOME/rpmbuild目录结构(y/n)
+5. 生成包含开源协议、上游信息的SOURCEINFO.yaml(欧拉或龙蜥仓库)
 
 示例：
-1. 克隆龙蜥仓库httpd的openEuler-24.03-LTS分支：
-   clone httpd openEuler-24.03-LTS
-   输入 a
-
-2. 克隆龙蜥仓库httpd的a8.9分支：
-   clone httpd a8.9
-   输入 b
-
-3. 克隆CQ内部仓库httpd的dev分支：
-   clone httpd dev
-   输入 c（或其他任意键）
+1. 克隆httpd
+   clone httpd
+
 EOF
 }
 
-# 参数校验
-if [[ $1 == "-h" || $1 == "--help" ]]; then
-    help_msg
-    exit 0
-fi
-
-package_name=$1
-branch=${2:-master}  # 默认分支
-current_path=$(pwd)
-
-# 检查包名
-if [ -z "$package_name" ]; then
-    echo "错误：缺少包名参数" >&2
-    exit 1
-fi
-
 # 清理旧目录
 clean_env() {
     echo "正在清理旧环境..."
-    rm -rf "$package_name" ~/rpmbuild
-    mkdir -p ~/rpmbuild/{BUILD,SOURCES,SPECS}
+    rm -rf "$PKG_PATH"
+    if [[ $dir == "y" ]]; then
+        rm -rf $HOME/rpmbuild
+    fi 
 }
 
 # 克隆仓库函数
 clone_repo() {
-    local repo_url=$1
-    echo "尝试克隆：$repo_url"
-    git clone -b "$branch" "$repo_url" && return 0
-    rm -rf "$package_name"  # 克隆失败清理残留
+    local upstream_url=$1
+    git clone -b "$branch" "$upstream_url" && return 0
+    rm -rf "$PKG_PATH"  # 克隆失败清理残留
     return 1
 }
 
-# 交互选择仓库
-read -p "请选择仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）: " choice
-choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]')
-
-case "$choice" in
-    a)
-        clean_env  # 初始化环境
-        repo_url="https://gitee.com/src-openeuler/${package_name}.git"
-        clone_repo "$repo_url" || CHECK_RESULT $? "欧拉仓库克隆失败"
-        ;;
-    b)
-        clean_env  # 初始化环境
-        repo_url="https://gitee.com/src-anolis-os/${package_name}.git"
-        clone_repo "$repo_url" || CHECK_RESULT $? "龙蜥仓库克隆失败"
-        ;;
-    *)
-        rm -rf "$package_name"
-        # CQ内部仓库列表（按优先级排序）
-        cq_repos=(
-            "http://192.168.10.152/cyos-security/public/$package_name.git"
-            "http://192.168.10.152/cyos-security/protected/$package_name.git"
-            "http://192.168.10.152/cyos-security/private/$package_name.git"
-            "http://192.168.10.152/cyos-security/trash/$package_name.git"
-            "http://192.168.10.152/cyos-security/iso/$package_name.git"
-            "http://192.168.10.152/cyos-security/$package_name.git"
-            "http://192.168.10.152/cyos-security/toolkits/$package_name.git"
-            "http://192.168.10.152/cyos-security/transition/python3.11/$package_name.git"
-            "http://192.168.10.152/cyos-security/transition/deb_to_rpm/$package_name.git"
-            "http://192.168.10.152/cyos-security/transition/xfce/$package_name.git"
-            "http://192.168.10.152/cyos-security/transition/$package_name.git"
-            "http://192.168.10.152/lixuebing/$package_name.git"
-        )
-
-        for repo in "${cq_repos[@]}"; do
-            git ls-remote $repo &>/dev/null && clone_repo "$repo" && break
-        done
-
-
-        if [ ! -f "$package_name/.gitignore" ] && [ -d "$package_name/SPECS" ]; then
-            cat > $package_name/.gitignore << EOF
-#rpm
-RPMS
-SRPMS
-BUILDROOT
-#vscode
-.vscode 
-EOF
-        fi
-        exit 0
-        ;;
-esac
-
 # 移动文件到rpmbuild目录
-move_files() {
-    echo "正在整理文件到 ~/rpmbuild..."
-    mv "$package_name"/*.spec ~/rpmbuild/SPECS/ || CHECK_RESULT $? "移动SPEC文件失败"
-    mv "$package_name"/* ~/rpmbuild/SOURCES/ || CHECK_RESULT $? "移动源码失败"
-    rm -rf "$package_name"
+mv_files() {
+    echo "正在创建工作路径目录结构 $WORK_PATH ..."
+    mkdir -p $WORK_PATH/{SPECS,SOURCES} && echo "创建工作路径目录结构成功" || { echo "创建工作路径目录结构失败"; exit 1; }
+    echo "--------------------"
+    echo "正在整理文件到 $WORK_PATH ..."
+    mv $PKG_PATH/*.spec $WORK_PATH/SPECS/ && echo "移动SPEC文件成功" || { echo "移动SPEC文件失败"; exit 1; }
+    find $PKG_PATH -maxdepth 1 -type f ! -name ".*" -exec mv {} $WORK_PATH/SOURCES/ \; && echo "移动资源文件成功"|| { echo "移动资源文件失败"; exit 1; }
+    if [[ $dir == "y" ]]; then
+        mv $PKG_PATH/.gitignore $WORK_PATH && echo "移动.gitignore文件成功" || { echo "移动.gitignore文件失败"; exit 1; }
+        rm -rf "$PKG_PATH"
+    else
+        rm -rf "$WORK_PATH/.git"
+    fi
+    echo "整理文件完成"
+    echo "--------------------"
 }
 
 # 生成元数据文件
 generate_metadata() {
-    cd ~/rpmbuild || return 1
+    cd "$WORK_PATH" || return 1
+    
     local spec_file=$(ls SPECS/*.spec 2>/dev/null)
     
     if [ -z "$spec_file" ]; then
         echo "错误：未找到SPEC文件" >&2
         exit 1
     fi
-
-    # 提取元数据
+    
     local url=$(awk '/^(URL|Url):/ {print $2}' "$spec_file")
     local license=$(grep -oP 'License:\s*\K.*' "$spec_file" | tr '\n' ' ')
-    
     # 确定上游仓库URL
     local upstream_url
-    if [ "$choice" = "a" ]; then
-        upstream_url="https://gitee.com/src-openeuler/${package_name}.git"
+    if [ "$repo" = "a" ]; then
+        upstream_url="https://gitee.com/src-openeuler/${PKG_NAME}.git"
     else
-        upstream_url="https://gitee.com/src-anolis-os/${package_name}.git"
+        upstream_url="https://gitee.com/src-anolis-os/${PKG_NAME}.git"
     fi
     
     # 写入YAML
@@ -170,8 +98,115 @@
   src: ${url:-"未指定上游地址"}
 EOF
 
-    echo "元数据文件生成完成：$(pwd)/SOURCEINFO.yaml"
+    echo "元数据文件生成完成 $(pwd)/SOURCEINFO.yaml"
+    echo "--------------------"
+}
+
+main() {
+    # 解析命令行参数（支持选项在任意位置）
+    while [[ $# -gt 0 ]]; do
+        case "$1" in
+            -h|--help)
+                show_help
+                exit 0
+                ;;
+            *)
+                # 如果参数不是选项，则认为是PKG_NAME
+                if [[ -z "$PKG_NAME" ]]; then
+                    PKG_NAME=$1
+                else
+                    echo "错误: 重复的路径参数 '$1'" >&2
+                    show_help
+                    exit 1
+                fi
+                ;;
+        esac
+        shift
+    done
+
+    # 检查包名
+    if [ -z "$PKG_NAME" ]; then
+        echo "错误：缺少包名参数" >&2
+        exit 1
+    fi
+
+    repo=$(read -p "请选择仓库类型（a=欧拉, b=龙蜥, 其他=CQ内部仓库）: " && echo "$REPLY")
+
+    branch=$(read -p "请输入克隆分支（默认master）: " && [[ -n "$REPLY" ]] && echo "$REPLY" || echo "master")
+
+    PKG_PATH="$(pwd)/$PKG_NAME"
+
+    dir=$(read -p "是否将代码放入$HOME/rpmbuild目录（输入y放入此目录，默认放到 $PKG_PATH 目录）: " && echo "$REPLY")
+    case "$repo" in
+        a)
+            clean_env  # 初始化环境
+            local upstream_url="https://gitee.com/src-openeuler/${PKG_NAME}.git"
+            clone_repo "$upstream_url" || { echo "龙蜥仓库克隆失败"; exit 1; }
+            echo "欧拉仓库克隆成功"
+            echo "--------------------"
+            ;;
+        b)
+            clean_env  # 初始化环境
+            local upstream_url="https://gitee.com/src-anolis-os/${PKG_NAME}.git"
+            clone_repo "$upstream_url" || { echo "龙蜥仓库克隆失败"; exit 1; }
+            echo "龙蜥仓库克隆成功"
+            echo "--------------------"
+            ;;
+        *)
+            clean_env  # 初始化环境
+            # CQ内部仓库列表（按优先级排序）
+            local cq_upstream_urls=(
+                "http://192.168.10.152/cyos-security/public/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/protected/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/private/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/trash/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/iso/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/toolkits/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/transition/python3.11/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/transition/deb_to_rpm/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/transition/xfce/$PKG_NAME.git"
+                "http://192.168.10.152/cyos-security/transition/$PKG_NAME.git"
+                "http://192.168.10.152/lixuebing/$PKG_NAME.git"
+            )
+            local upstream_url=""
+            for upstream_url in "${cq_upstream_urls[@]}"; do
+                git ls-remote $upstream_url &>/dev/null && clone_repo "$upstream_url" && break
+            done
+            ;;
+    esac
+    if [ ! -f "$PKG_PATH/.gitignore" ] && $(find $PKG_PATH -name '*.spec' &>/dev/null && echo "true"); then
+        echo "正在创建.gitignore文件..."
+        cat > $PKG_PATH/.gitignore << EOF
+#rpm
+RPMS
+SRPMS
+BUILDROOT
+#vscode
+.vscode 
+EOF
+        if [ $? -eq 0 ]; then
+            echo ".gitignore文件创建成功" 
+            echo "--------------------"  
+        else
+            echo ".gitignore文件创建失败"
+            exit 1      
+        fi
+    fi
+
+    if [[ $repo != "a" && $repo != "b" ]]; then
+        echo "CQ内部仓库克隆成功!"
+        exit 0
+    fi
+
+    if [[ $dir == "y" ]]; then
+        WORK_PATH="$HOME/rpmbuild"  # 放入$HOME/rpmbuild目录
+    else
+        WORK_PATH="$PKG_PATH"  # 保持原目录结构
+    fi
+    mv_files
+
+    generate_metadata && echo "操作完成！RPM构建环境已配置到 $PKG_PATH" || { echo "元数据生成失败"; exit 1; }
 }
 
-# 执行主流程
-move_files && generate_metadata && echo "操作完成！RPM构建环境已配置到 ~/rpmbuild"
+main "$@"
